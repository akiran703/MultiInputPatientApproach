"""finalpredictionmodel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/akiran703/MultiInputPatientApproach/blob/master/finalpredictionmodel.ipynb
"""

from PIL import Image
import glob
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from sklearn.model_selection import train_test_split
import numpy as np
import tensorflow.keras as tf
from tensorflow.keras import Sequential
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.callbacks import CSVLogger
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten,Concatenate, Dropout
from tensorflow.keras.utils import to_categorical
from keras import backend as K
import os
import pandas as pd
import csv
import cv2
import random
import glob
from IPython.core.debugger import Tracer
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
import itertools
import matplotlib.pyplot as plt


from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
from google.colab import files


def main():
            auth.authenticate_user()
            gauth = GoogleAuth()
            gauth.credentials = GoogleCredentials.get_application_default()
            drive = GoogleDrive(gauth)

            download_CT_COVID = drive.CreateFile({'id':'1bDI0Lokr1Do1adDq6kY2I6NIedaPGDbS'})
            download_CT_COVID.GetContentFile('clustercovid.zip')

            #-------------------------------setting up the data for training, validation and test--------------------------------------------------------------------------------

            file = files.upload()

            dfcovidtest = pd.read_csv('update_covid_test.csv')
            patientidcovidtest = dfcovidtest["Patient ID"].value_counts().keys().tolist()



            dfcovidtrain = pd.read_csv('update_covid_train.csv')
            patientidcovidtrain = dfcovidtrain["Patient ID"].value_counts().keys().tolist()
     


            dfcovidval = pd.read_csv('update_covid_val.csv')
            patientidcovidval = dfcovidval["Patient ID"].value_counts().keys().tolist()
       



            dfnoncovidtest = pd.read_csv('update_noncovid_test.csv')
            patientidnoncovidtest = dfnoncovidtest["patient id"].value_counts().keys().tolist()
     



            dfnoncovidtrain = pd.read_csv('update_noncovid_train.csv')
            patientidnoncovidtrain = dfnoncovidtrain["patient id"].value_counts().keys().tolist()
        



            dfnoncovidval = pd.read_csv('update_noncovid_val.csv')
            patientidnoncovidval = dfnoncovidval["patient id"].value_counts().keys().tolist()
           

            covidtest = []
            covidtrain = []
            covidval = []

            covidtestlabel = []
            covidtrainlabel = []
            covidvallabel = []

            covidtestid = []
            covidtrainid = []
            covidvalid = []

            noncovidtest = []
            noncovidtrain = []
            noncovidval = []

            noncovidtestlabel = []
            noncovidtrainlabel = []
            noncovidvallabel = []


            noncovidtestid = []
            noncovidtrainid = []
            noncovidvalid = []

            desired_size=200            
            
            #---------------------------------------normalize covid images------------------------
            def myFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    covidtest.append(normresize)
                    covidtestlabel.append(1)



            def trainmyFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    covidtrain.append(normresize)
                    covidtrainlabel.append(1)



            def valmyFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    covidval.append(normresize)
                    covidvallabel.append(1)



            def seekvalue(y):
                findValue = dfcovidtest.loc[dfcovidtest['Patient ID'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['File name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_COVID/{image_value}'
                    covidtestid.append(y)
                    myFunc(f1)


            def trainseekvalue(y):
                findValue = dfcovidtrain.loc[dfcovidtrain['Patient ID'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['File name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_COVID/{image_value}'
                    covidtrainid.append(y)
                    trainmyFunc(f1)

            def valseekvalue(y):
                findValue = dfcovidval.loc[dfcovidval['Patient ID'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['File name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_COVID/{image_value}'
                    covidvalid.append(y)
                    valmyFunc(f1)



            for i in range(len(patientidcovidtest)):
                seekvalue(patientidcovidtest[i])


            for i in range(len(patientidcovidtrain)):
                trainseekvalue(patientidcovidtrain[i])

            for i in range(len(patientidcovidval)):
                valseekvalue(patientidcovidval[i])


            #---------------------------------normalize noncovid images-----------------

            def nonmyFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    noncovidtest.append(normresize)
                    noncovidtestlabel.append(0)


            def nontrainmyFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    noncovidtrain.append(normresize)
                    noncovidtrainlabel.append(0)


            def nonvalmyFunc(name):
                    img = cv2.imread(name)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = cv2.normalize(imgreszie, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
                    noncovidval.append(normresize)
                    noncovidvallabel.append(0)



            def nonseekvalue(y):
                findValue = dfnoncovidtest.loc[dfnoncovidtest['patient id'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['image name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_NonCOVID/{image_value}'
                    noncovidtestid.append(y)
                    nonmyFunc(f1)


            def nontrainseekvalue(y):
                findValue = dfnoncovidtrain.loc[dfnoncovidtrain['patient id'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['image name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_NonCOVID/{image_value}'
                    noncovidtrainid.append(y)
                    nontrainmyFunc(f1)

            def nonvalseekvalue(y):
                findValue = dfnoncovidval.loc[dfnoncovidval['patient id'] == y]
                for i, row in findValue.iterrows():
                    image_value = f"{row['image name']}"
                    f1 = f'/content/Data/clustercovid/coviddata/CT_NonCOVID/{image_value}'
                    noncovidvalid.append(y)
                    nonvalmyFunc(f1)


            for i in range(len(patientidnoncovidtest)):
                nonseekvalue(patientidnoncovidtest[i])

            for i in range(len(patientidnoncovidtrain)):
                nontrainseekvalue(patientidnoncovidtrain[i])

            for i in range(len(patientidnoncovidval)):
                nonvalseekvalue(patientidnoncovidval[i])
                
            #----------------------------------------------------combine covid + noncovid iamges and randomize it-----------

            test = noncovidtest + covidtest
            train = covidtrain + noncovidtrain
            val = noncovidval + covidval

            testlabel = covidtestlabel + noncovidtestlabel
            trainlabel = noncovidtrainlabel + covidtrainlabel
            vallabel = covidvallabel + noncovidvallabel

            testid = noncovidtestid + covidtestid
            trainid = noncovidtrainid + covidtrainid
            valid = covidvalid + noncovidvalid

       

            rand_order = np.random.permutation(len(test))
            test = np.array(test)
            test = test[rand_order, :, :, :]
            testlabel = to_categorical(testlabel)
            testlabel = testlabel[rand_order]
            testid = np.array(testid)
            testid = testid[rand_order]


            rand_order = np.random.permutation(len(train))
            train = np.array(train)
            train = train[rand_order, :, :, :]
            trainlabel = to_categorical(trainlabel)
            trainlabel = trainlabel[rand_order]
            trainid = np.array(trainid)
            trainid = trainid[rand_order]

            rand_order = np.random.permutation(len(val))
            val = np.array(val)
            val = val[rand_order, :, :, :]
            vallabel = to_categorical(vallabel)
            vallabel = vallabel[rand_order]
            valid = np.array(valid)
            valid = valid[rand_order]
            
            
            #---------------------------------build neural network--------------------------------

            inputs = Input(shape = (desired_size, desired_size, 3))
            add1 = (Conv2D(96, (3, 3), activation='relu', padding='valid'))(inputs)
            max1 = (MaxPooling2D((2, 2)))(add1)
            add2 = (Conv2D(256, (5, 5), activation='relu', strides=1, padding='same'))(max1)
            max2 = (MaxPooling2D((3, 3)))(add2)
            add3 = (Conv2D(384, (3, 3), activation='relu', strides=1, padding='same'))(max2)
            add4 = (Conv2D(384, (3, 3), activation='relu', strides=1, padding='same'))(add3)
            add5 = (Conv2D(256, (3, 3), activation='relu', strides=1, padding='same'))(add4)
            max3 = (MaxPooling2D((3, 3)))(add5)

            flattenmax = Flatten()(max3)
            dense1 = (Dense(512, activation='relu'))(flattenmax)
            dense2 = (Dense(512, activation='relu'))(dense1)
            output = (Dense(2, activation='softmax'))(dense2)
            model = Model(inputs = inputs,outputs = output)
            model.summary()


            #---------------------------------------train model and save weights for transfer learning---------------------------
            #save weights
            checkpoint_filepath = '/content/checkpoint_predictionmodel.hdf5'
            model_checkpoint_callback = tf.callbacks.ModelCheckpoint(filepath=checkpoint_filepath,save_weights_only=True,
                monitor='val_loss',
                mode='min',
                save_best_only=True)

            csv_log_paper = CSVLogger("prediction_paper.csv")

            # complie
            optimizer=tf.optimizers.SGD(learning_rate=0.05)
            model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

            #history = model.fit(x=[pic1,pic2,pic3,pic4], y=endtrainlabel, batch_size=32, epochs=20,verbose=True,validation_data=([pic111,pic222,pic333,pic444],endvalabel))
            history = model.fit(train, trainlabel, batch_size=32, epochs=50, callbacks=[model_checkpoint_callback],verbose=True, validation_data=(val,vallabel))

            model.load_weights(checkpoint_filepath)

            download_transfer = drive.CreateFile({'id':'1NTcd09yqjCh5a3kkWqiCGcclv8Nwo63q'})
            download_transfer.GetContentFile('archive.zip')


            
            #-------------------------load in second data (this data has images associated with patient)-----------------------

            img_dir_transfer = "/content/transfer/New_Data_CoV2/Covid"
            img_dirnon_transfer = "/content/transfer/New_Data_CoV2/Healthy"

            healthy_patient_dirs = glob.glob("/content/transfer/New_Data_CoV2/Healthy/*/")
            covid_patient_dirs = glob.glob("/content/transfer/New_Data_CoV2/Covid/*/")

            # read in on an image-by-image basis
            healthy_patient_imgs = glob.glob("/content/transfer/New_Data_CoV2/Healthy/*/*.png")
            covid_patient_imgs = glob.glob("/content/transfer/New_Data_CoV2/Covid/*/*.png")

            img_covid =[]
            img_covid_label = []

            img_healthy =[]
            img_healthy_label = []

            covidtransferid = []
            healthytransferid = []

            counter = 0
            healthycounter = 1
            
            #---------------------------normalize covid and noncovid images-------------

            for curr_dir in healthy_patient_dirs:
                imgs = glob.glob(curr_dir+'/*.png')
                for img in imgs:
                    img = cv2.imread(img)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = (imgreszie* 1.0)/np.max(imgreszie)
                    img_healthy.append(normresize)
                    healthytransferid.append(healthycounter)
                    img_healthy_label.append([1])
                healthycounter = healthycounter + 2

            for curr_dir in covid_patient_dirs:
                imgs = glob.glob(curr_dir+'/*.png')
                for img in imgs:
                    img = cv2.imread(img)
                    old_size = img.shape[:2]
                    ratio = float(desired_size) / max(old_size)
                    new_size = tuple([int(x * ratio) for x in old_size])
                    img = cv2.resize(img, (new_size[1], new_size[0]))
                    delta_w = desired_size - new_size[1]
                    delta_h = desired_size - new_size[0]
                    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
                    left, right = delta_w // 2, delta_w - (delta_w // 2)
                    color = [0, 0, 0]
                    imgreszie = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
                    normresize = (imgreszie* 1.0)/np.max(imgreszie)
                    img_covid.append(normresize)
                    covidtransferid.append(counter)
                    img_covid_label.append([0])
                counter = counter + 2

            #-----------------------------------break data into training, test, and validation + randomized----------------

            finaltrain = []
            finaltrainlabel = []
            finaltrainid = []


            finalval = []
            finalvallabel = []
            finalvalid = []


            finaltest = []
            finaltestlabel = []
            finaltestid = []

            for i in range(0,606):
                finaltrain.append(img_healthy[i])
                finaltrainlabel.append(img_healthy_label[i])
                finaltrainid.append(healthytransferid[i])


            for i in range(0,1755):
                finaltrain.append(img_covid[i])
                finaltrainlabel.append(img_covid_label[i])
                finaltrainid.append(covidtransferid[i])

            for i in range(606,757):
                finaltest.append(img_healthy[i])
                finaltestlabel.append(img_healthy_label[i])
                finaltestid.append(healthytransferid[i])

            for i in range(1755, 2167):
                finaltest.append(img_covid[i])
                finaltestlabel.append(img_covid_label[i])
                finaltestid.append(covidtransferid[i])



            for i in range(506,823):
                finalval.append(finaltrain[i])
                finalvallabel.append(finaltrainlabel[i])
                finalvalid.append(finaltrainid[i])

            del finaltrain[506:823]
            del finaltrainid[506:823]
            del finaltrainlabel[506:823]



            rand_order_train = np.random.permutation(len(finaltrain))
            rand_order_test = np.random.permutation(len(finaltest))
            rand_order_val = np.random.permutation(len(finalval))

            finaltrain = np.array(finaltrain)
            finaltrain = finaltrain[rand_order_train, :, :, :]

            finaltest = np.array(finaltest)
            finaltest = finaltest[rand_order_test, :, :, :]

            finalval = np.array(finalval)
            finalval = finalval[rand_order_val, :, :, :]

            finaltrainlabel = to_categorical(finaltrainlabel)
            finaltrainlabel = finaltrainlabel[rand_order_train]

            finaltestlabel = to_categorical(finaltestlabel)
            finaltestlabel = finaltestlabel[rand_order_test]

            finalvallabel = to_categorical(finalvallabel)
            finalvallabel = finalvallabel[rand_order_val]



            finaltrainid = np.array(finaltrainid)
            finaltrainid = finaltrainid[rand_order_train]

            finaltestid = np.array(finaltestid)
            finaltestid = finaltestid[rand_order_test]

            finalvalid = np.array(finalvalid)
            finalvalid = finalvalid[rand_order_val]

            print(finaltrainlabel)

           

            #------------------------------------------------functions to calculate metrics---------------------------------------------------------
         

            def recall_m(y_true, y_pred):
                true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
                possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
                recall = (true_positives * 1.0) / (possible_positives + K.epsilon())
                return recall

            def precision_m(y_true, y_pred):
                true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
                predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
                precision = (true_positives * 1.0) / (predicted_positives + K.epsilon())
                return precision

            def f1_m(y_true, y_pred):
                precision = precision_m(y_true, y_pred)
                recall = recall_m(y_true, y_pred)
                return 2*((precision*recall)/(precision+recall+K.epsilon()))

            #-----------------------------------------------------------------------model makes the predictions with transfer learning-----------------
            checkpoint_filepath = "/content/checkpoint_predictionmodel.hdf5"

            
            checkpoint_filepath_1 = '/content/please_work.hdf5'
            model_checkpoint_callback = tf.callbacks.ModelCheckpoint(filepath=checkpoint_filepath_1,save_weights_only=True,
                monitor='val_loss',
                mode='min',
                save_best_only=True)
            
            
            optimizer = tf.optimizers.SGD(learning_rate=0.05)
            model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

            model.load_weights(checkpoint_filepath)
            history = model.fit(finaltrain, finaltrainlabel, batch_size=32, epochs=50,callbacks=[model_checkpoint_callback],verbose=True,validation_data=(finalval,finalvallabel))

            model.load_weights(checkpoint_filepath_1)

            prediction = model.predict(finaltest,verbose=1)


            #-------------------------------------we store the patient id in a dictionary and count how many images they have in the testing data set


            def getDuplicatesWithInfo(listOfElems):
                ''' Get duplicate element in a list along with their indices in list and frequency count'''
                dictOfElems = dict()
                index = 0
                # Iterate over each element in list and keep track of index
                for elem in listOfElems:
                    # If element exists in dict then keep its index in lisr & increment its frequency
                    if elem in dictOfElems:
                        dictOfElems[elem][0] += 1
                        dictOfElems[elem][1].append(index)

                    else:
                        # Add a new entry in dictionary
                        dictOfElems[elem] = [1, [index]]
                    index += 1

                dictOfElems = { key:value for key, value in dictOfElems.items() if value[0] > 1}
                return dictOfElems

            dictOfElems = getDuplicatesWithInfo(finaltestid)
            for key, value in dictOfElems.items():
                    print('Element = ', key , ' :: Repeated Count = ', value[0] , ' :: Index Positions =  ', value[1])



            #---------------------------------------------------------average approach-----------------------------


            finalpred = []
            actuallabel = []

            for key, value in dictOfElems.items():
                sum = 0
                evaluation =0
                for i in range(dictOfElems[key][0]):
                    print(prediction[dictOfElems[key][1][i]][1])
                    sum = sum + prediction[dictOfElems[key][1][i]][1]
                print(dictOfElems[key][0])
                sum = sum/dictOfElems[key][0]
                print(sum)
                if(sum < .50):
                    evaluation = 0
                    finalpred.append(tf.cast(evaluation,tf.float32))
                elif(sum > .50):
                    evaluation = 1
                    finalpred.append(tf.cast(evaluation,tf.float32))
                actualvalue = finaltestlabel[dictOfElems[key][1][i]]
                actuallabel.append(tf.cast(actualvalue[1],tf.float32))
                print('Element = ', key ,' :: prediction evaluation = ',evaluation,' :: label = ',actualvalue[1] )
            finalpred = np.array(finalpred)
            actuallabel = np.array(actuallabel)


            #-------------------------------------majority vote counting-----------------------------------
            print("MAJORITY VOTE EVALUATION")


            finalpred_majority = []
            actuallabel_majority = []

            for key, value in dictOfElems.items():
                covid_votes = 0
                non_covid_votes = 0
                
                print(f"\nPatient ID: {key}")
                print("Individual slice predictions:")
                
                # Count votes for each slice
                for i in range(dictOfElems[key][0]):
                    slice_prediction = prediction[dictOfElems[key][1][i]][1]  # COVID probability
                    print(f"  Slice {i+1}: COVID prob = {slice_prediction:.4f}")
                    
                    # Vote based on 0.5 threshold
                    if slice_prediction > 0.5:
                        covid_votes += 1
                        print(f"    → Vote: COVID")
                    else:
                        non_covid_votes += 1
                        print(f"    → Vote: Non-COVID")
                
                # Final diagnosis based on majority vote
                total_slices = covid_votes + non_covid_votes
                print(f"\nVoting Summary:")
                print(f"  COVID votes: {covid_votes}/{total_slices}")
                print(f"  Non-COVID votes: {non_covid_votes}/{total_slices}")
                
                if covid_votes > non_covid_votes:
                    final_diagnosis = 1
                    print(f"  → MAJORITY VOTE DIAGNOSIS: COVID")
                elif non_covid_votes > covid_votes:
                    final_diagnosis = 0
                    print(f"  → MAJORITY VOTE DIAGNOSIS: Non-COVID")
                else:
                    # Tie-breaking: default to non-COVID (conservative approach)
                    final_diagnosis = 0
                    print(f"  → TIE: Defaulting to Non-COVID (conservative)")
                
                finalpred_majority.append(tf.cast(final_diagnosis, tf.float32))
                
                # Get actual label
                actualvalue = finaltestlabel[dictOfElems[key][1][0]]  # Same for all slices of this patient
                actuallabel_majority.append(tf.cast(actualvalue[1], tf.float32))
                
                print(f"  Actual label: {'COVID' if actualvalue[1] == 1 else 'Non-COVID'}")
                print(f"  Correct: {'✓' if final_diagnosis == actualvalue[1] else '✗'}")

            # Convert to numpy arrays
            finalpred_majority = np.array(finalpred_majority)
            actuallabel_majority = np.array(actuallabel_majority)




            #---------------------------------------------Display data----------------------------------------------------------------



            # output both methods

            print("Averaging methond RESULTS")

            print("AVERAGING METHOD:")
            print(f"  Recall: {recall_m(actuallabel, finalpred):.2f}")
            print(f"  Precision: {precision_m(actuallabel, finalpred):.2f}")
            print(f"  F1-Score: {f1_m(actuallabel, finalpred):.2f}")


            print(classification_report(y_true=actuallabel, y_pred=finalpred))

            tn, fp, fn, tp = confusion_matrix(y_true=actuallabel, y_pred=finalpred).ravel()
            (tn, fp, fn, tp)


            print("MAJORITY VOTE RESULTS")


            print("MAJORITY VOTE METHOD:")
            print(f"  Recall: {recall_m(actuallabel_majority, finalpred_majority):.2f}")
            print(f"  Precision: {precision_m(actuallabel_majority, finalpred_majority):.2f}")
            print(f"  F1-Score: {f1_m(actuallabel_majority, finalpred_majority):.2f}")



            print(classification_report(y_true=actuallabel_majority, y_pred=finalpred_majority))

            tn, fp, fn, tp = confusion_matrix(y_true=actuallabel_majority, y_pred=finalpred_majority).ravel()
            (tn, fp, fn, tp)


if __name__ == '__main__':
    main()






